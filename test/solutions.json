{
  "diamond" : "(ns diamond)\r\n\r\n(def alphabet (map char (range (int \\A) (inc (int \\Z)))))\r\n\r\n(defn- pad [x]\r\n  (apply str (repeat x \" \")))\r\n\r\n(defn- one-row [letter [inner-padding outer-padding]]\r\n  (if (= inner-padding 0)\r\n    (str (pad outer-padding) letter (pad outer-padding))\r\n    (str (pad outer-padding) letter (pad inner-padding) letter (pad outer-padding))))\r\n\r\n(defn- row-paddings [num-letters]\r\n  (let [inner-padding (conj (iterate (partial + 2) 1) 0)\r\n        outer-padding (iterate dec (dec num-letters))]\r\n    (take num-letters (map vector inner-padding outer-padding))))\r\n\r\n(defn diamond [c]\r\n  (let [num-letters (- (int c) (dec (int \\A)))\r\n        top-half (map one-row alphabet (row-paddings num-letters))]\r\n    (concat top-half (rest (reverse top-half)))))\r\n\r\n",
  "isogram" : "(ns isogram\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn isogram? [word]\r\n  (apply distinct? (filter #(Character/isLetter %) (str/lower-case word))))\r\n",
  "complex_numbers" : "(ns complex-numbers)\r\n\r\n(defn real [c] (first c))\r\n\r\n(defn imaginary [c] (last c))\r\n\r\n(defn abs [c] (Math/sqrt (apply + (map #(Math/pow % 2) [(first c) (last c)]))))\r\n\r\n(defn conjugate [c] [(first c) (- (last c))])\r\n\r\n(defn add [c1 c2] [(+ (first c1) (first c2)) (+ (last c1) (last c2))])\r\n\r\n(defn sub [c1 c2] [(- (first c1) (first c2)) (- (last c1) (last c2))])\r\n\r\n(defn mul [c1 c2] [(- (* (first c1) (first c2)) (* (last c1) (last c2)))\r\n             (+ (* (first c1) (last c2)) (* (last c1) (first c2)))])\r\n\r\n(defn div [c1 c2]\r\n    (let [denominator (apply + (map #(Math/pow % 2) [(first c2) (last c2)]))]\r\n        [(/ (+ (* (first c1) (first c2)) (* (last c1) (last c2))) denominator)\r\n          (/ (- (* (last c1) (first c2)) (* (first c1) (last c2))) denominator)]))\r\n",
  "gigasecond" : "(ns gigasecond)\n     \n      (defn leap-year? [year]\n        (cond\n          (zero? (mod year 400)) true\n          (zero? (mod year 100)) false\n          :else (zero? (mod year 4))))\n     \n      (defn days-in-month [year month]\n        (cond\n          (= month 2) (if (leap-year? year) 29 28)\n          (some #(= month %) [4 6 9 11]) 30\n          :else 31))\n     \n      (defn days-to-next-month [year month day]\n        (+ (days-in-month year month) (- day) 1))\n     \n      (defn from [y m d]\n        (let [total-seconds 1000000000\n              seconds-per-day 86400\n              total-days (int (/ total-seconds seconds-per-day))]\n          (loop [year y\n                 month m\n                 day d\n                 remaining total-days]\n            (let [jump (days-to-next-month year month day)]\n              (if-not (>= remaining jump)\n                [year month (+ day remaining)]\n                (recur\n                 (if (zero? (mod month 12)) (inc year) year)\n                 (inc (mod month 12))\n                 1\n                 (- remaining jump)))))))",
  "difference_of_squares" : "(ns difference-of-squares)\r\n\r\n(defn- sum [xs] (reduce + 0 xs))\r\n\r\n(defn sum-of-squares [n]\r\n  (sum (map #(int (Math/pow % 2)) (range 0 (inc n)))))\r\n\r\n(defn square-of-sum [n]\r\n  (int (Math/pow (sum (range 0 (inc n))) 2)))\r\n\r\n(defn difference [x]\r\n  (- (square-of-sum x) (sum-of-squares x)))\r\n",
  "pascals_triangle" : "(ns pascals-triangle)\r\n\r\n(defn- next-row [row]\r\n  (lazy-seq (->> (partition-all 2 1 row)\r\n                 (map (partial apply +'))\r\n                 (cons 1))))\r\n\r\n(def triangle (iterate next-row [1]))\r\n\r\n(defn row [n] (nth triangle (dec n)))\r\n",
  "leap" : "(ns leap)\r\n\r\n(defn leap-year? [year]\r\n    (let [pcs  (map #(= 0 (rem year %1)) [4 100 400])\r\n        p (first pcs)\r\n     c (second pcs)\r\n        s (last pcs)]\r\n    (or (and p (not c))\r\n        (and c s))))\r\n",
  "zipper" : "(ns zipper)\r\n\r\n(defn from-trail [tree last]\r\n  (if (= (nth last 0) \"left\")\r\n    {:value (nth last 1), :left tree, :right (nth last 2)}\r\n    {:value (nth last 1), :left (nth last 2), :right tree}))\r\n\r\n(defn from-tree [tree]\r\n  {:tree tree :trail []})\r\n\r\n(defn value [z]\r\n  (:value (:tree z)))\r\n\r\n(defn zipper [tree trail]\r\n  {:tree tree :trail trail})\r\n\r\n(defn left [z]\r\n  (when (:left (:tree z))\r\n    (zipper (:left (:tree z))\r\n            (conj [[\"left\" (:value (:tree z)) (:right (:tree z))]]\r\n                  (:trail z)))))\r\n(defn right [z]\r\n  (when (:right (:tree z))\r\n    (zipper (:right (:tree z))\r\n            (conj [[\"right\" (:value (:tree z)) (:left (:tree z))]]\r\n                  (:trail z)))))\r\n\r\n(defn rebuild-tree [tree trail]\r\n  (if (= 0 (count trail))\r\n    tree\r\n    (recur (from-trail tree (first trail)) (fnext trail))))\r\n\r\n(defn to-tree [z]\r\n  (rebuild-tree (:tree z) (:trail z)))\r\n\r\n(defn up [z]\r\n  (when-not (zero? (count (:trail z)))\r\n    (zipper (from-trail (:tree z) (first (:trail z)))\r\n            (fnext (:trail z)))))\r\n\r\n(defn set-value [z value]\r\n  (zipper {:value value,\r\n           :left  (:left (:tree z)),\r\n           :right (:right (:tree z))}\r\n          (:trail z)))\r\n\r\n(defn set-left [z left]\r\n  (zipper {:value (:value (:tree z)),\r\n           :left  left,\r\n           :right (:right (:tree z))}\r\n          (:trail z)))\r\n\r\n(defn set-right [z right]\r\n  (zipper {:value (:value (:tree z)),\r\n           :left  (:left (:tree z)),\r\n           :right right}\r\n          (:trail z)))\r\n",
  "minesweeper" : "(ns minesweeper\r\n  (:require [clojure.pprint :refer [cl-format]]\r\n            [clojure.string :refer [split-lines]]))\r\n\r\n(defn- windows [field]\r\n  (->> field\r\n       (map #(partition 3 1 `(nil ~@% nil)))\r\n       (apply map #(partition 3 1 `(nil ~@%& nil)))\r\n       (apply map vector)))\r\n\r\n(defn- count-mines-around [[[a b c]\r\n                            [d e f]\r\n                            [g h i]]]\r\n  (if-let [mines-count (and (= \\space e)\r\n                            (count (filter #{\\*} [a b c d f g h i])))]\r\n    (if (zero? mines-count)\r\n      \\space\r\n      mines-count)\r\n    e))\r\n\r\n(defn draw [field]\r\n  (if (empty? field) \"\"\r\n      (->> field\r\n           split-lines\r\n           windows\r\n           (map (fn [line] (map count-mines-around line)))\r\n           (cl-format nil \"~{~{~a~}~^~%~}\"))))\r\n",
  "space_age" : "(ns space-age)\r\n\r\n(def  seconds-in-year (* 365.25 24 60 60))\r\n\r\n(def  factors {:mercury 0.2408467\r\n                        :venus   0.61519726\r\n                        :earth   1.0\r\n                        :mars    1.8808158\r\n                        :jupiter 11.862615\r\n                        :saturn  29.447498\r\n                        :uranus  84.016846\r\n                        :neptune 164.79132})\r\n\r\n(doseq [[planet factor] factors]\r\n  (let [fn-name (symbol (str \"on-\" (name planet)))]\r\n    (intern *ns* fn-name\r\n            (fn [seconds]\r\n              (/ (/ seconds seconds-in-year) factor)))))\r\n",
  "flatten_array" : "(ns flatten-array\r\n  (:refer-clojure :exclude [flatten]))\r\n\r\n(defn flatten [s]\r\n  (->> s\r\n       (tree-seq sequential? seq)\r\n       rest\r\n       (remove sequential?)\r\n       (remove nil?)))\r\n",
  "crypto_square" : "(ns crypto-square\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn normalize-plaintext [plaintext]\r\n  (str/lower-case (str/replace plaintext #\"[^\\w]\" \"\")))\r\n\r\n(defn square-size [plaintext]\r\n  (int (Math/ceil (Math/sqrt (count (normalize-plaintext plaintext))))))\r\n\r\n(defn plaintext-segments [plaintext]\r\n  (let [normalized-plaintext (normalize-plaintext plaintext)\r\n        size (square-size normalized-plaintext)]\r\n    (map #(apply str %) (partition size size nil normalized-plaintext))))\r\n\r\n(defn- padded-segments [plaintext pad]\r\n  (let [segments (plaintext-segments plaintext)\r\n        r (count (first segments))]\r\n        (map #(concat % (take (- r (count %)) (repeat pad))) segments)))\r\n\r\n(defn ciphertext [plaintext]\r\n  (apply str (apply mapcat vector (padded-segments plaintext nil))))\r\n\r\n(defn normalize-ciphertext [plaintext]\r\n  (str/join \" \" (map #(apply str %) (apply map vector (padded-segments plaintext \\ )))))\r\n",
  "pov" : "(ns pov\r\n  (:require [clojure.zip :as zip]))\r\n\r\n(defn- remove-child\r\n  \"Remove a child from a node\"\r\n  [parent child]\r\n  (filter #(not= child %) parent))\r\n\r\n(defn- reparent\r\n  \"Take a node, and make it the parent of its parent\"\r\n  [loc]\r\n  (let [current (zip/node loc)\r\n        parent (zip/up loc)\r\n        belonged-to (when parent\r\n                      (-> parent\r\n                          (zip/edit remove-child current)\r\n                          reparent\r\n                          list))]\r\n    (vec (concat current belonged-to))))\r\n\r\n(defn- find-node\r\n  \"Find the node whose identifier matches the given value\"\r\n  [v tree]\r\n  (loop [loc (-> tree zip/vector-zip zip/next)]\r\n    (cond (= v (zip/node loc)) (zip/up loc)\r\n          (zip/end? loc) nil\r\n          :else (recur (zip/next loc)))))\r\n\r\n(defn of\r\n  \"Find a node by its identifier and raise to the root\"\r\n  [s tree]\r\n  (when-let [loc (find-node s tree)]\r\n    (reparent loc)))\r\n\r\n(defn path-from-to\r\n  \"Find a path from src node to dest node\"\r\n  [src dest graph]\r\n  (when-let [loc (find-node dest (of src graph))]\r\n    (let [dest-node (zip/node loc)\r\n          path (concat (zip/path loc) [dest-node])]\r\n      (map first path))))\r\n\r\n",
  "prime_factors" : "(ns prime-factors)\r\n\r\n#_(defn- least-prime-divisor\r\n  [number]\r\n  (or (first\r\n       (filter #(zero? (rem number %1))\r\n               (range 2 (inc (/ number 2)))))\r\n      number))\r\n\r\n(defn of [number]\r\n  (if\r\n   (< number 2) []\r\n   (let [divisor (least-prime-divisor number)]\r\n     (into [divisor] (of (/ number divisor))))))\r\n",
  "dominoes" : "(ns dominoes)\r\n\r\n(defn next-stones [n ds]\r\n  (for [i (range (count ds))\r\n        :let [[l [[a b] & r]] (split-at i ds)\r\n              m (cond (= a n) b (= b n) a)]\r\n        :when m]\r\n    [m (concat l r)]))\r\n\r\n(defn chain-end [b ds]\r\n  (some (fn [[b ds]]\r\n          (if (empty? ds) b (chain-end b ds)))\r\n        (next-stones b ds)))\r\n\r\n(defn can-chain? [[[a b] & ds]]\r\n  (cond (nil? a) true\r\n        (nil? ds) (= a b)\r\n        :else (= a (chain-end b (vec ds)))))",
  "spiral_matrix" : "(ns spiral-matrix)\r\n\r\n(defn spiral-matrix [m n & [s]]\r\n  (let [row (list (map #(+ s %) (range m)))]\r\n    (if (= 1 n) row\r\n        (->> (spiral-matrix (dec n) m (+ s m))\r\n             (apply map list)\r\n             (map reverse)\r\n             (concat row)))))\r\n\r\n(defn spiral [n] (if (zero? n) '() (spiral-matrix n n 1)))\r\n",
  "robot_name" : "(ns robot-name)\r\n\r\n(def  letters (map char (range 65 91)))\r\n\r\n(defn generate-name [] \r\n (apply str (concat (repeatedly 2 (fn [] (rand-nth letters)))  \r\n    (repeatedly 3 (fn [] (rand-int 10))))))\r\n\r\n(defn robot []\r\n  (atom {:name (generate-name)}))\r\n\r\n(defn robot-name [robot]\r\n  (get (deref robot) :name))\r\n\r\n(defn reset-name [robot]\r\n  (swap! robot assoc :name (generate-name)))\r\n",
  "roman_numerals" : "(ns roman-numerals)\r\n\r\n(def  numeral-mapping [[1000 \"M\"]\r\n                                [900 \"CM\"]\r\n                                [500 \"D\"]\r\n                                [400 \"CD\"]\r\n                                [100 \"C\"]\r\n                                [90 \"XC\"]\r\n                                [50 \"L\"]\r\n                                [40 \"XL\"]\r\n                                [10 \"X\"]\r\n                                [9 \"IX\"]\r\n                                [5 \"V\"]\r\n                                [4 \"IV\"]\r\n                                [1 \"I\"]])\r\n\r\n(defn- largest-factor [number]\r\n  (first (filter\r\n          (fn [n] (<= (first n) number))\r\n          numeral-mapping)))\r\n\r\n(defn numerals [number]\r\n  (if\r\n   (zero? number) \"\"\r\n   (let [l (largest-factor number)\r\n         remainder (- number (first l))]\r\n     (str (last l) (numerals remainder)))))\r\n",
  "nucleotide_count" : "(ns nucleotide-count)\r\n\r\n(def ^{:private :const} dna-nucleotides #{\\A \\C \\G \\T})\r\n\r\n(def ^{:private :const} base-count\r\n  (zipmap dna-nucleotides (repeat 0)))\r\n\r\n(defn nucleotide-counts\r\n  \"generate a map of counts per nucleotide in strand\"\r\n  [strand]\r\n  (into base-count (frequencies strand)))\r\n\r\n(defn count-of-nucleotide-in-strand\r\n  \"count occurrences of nucleotide in strand\"\r\n  [nucleotide strand]\r\n  (or ((nucleotide-counts strand) nucleotide)\r\n      (throw (Exception. (str \"invalid nucleotide '\" nucleotide \"'\")))))\r\n",
  "run_length_encoding" : "(ns run-length-encoding)\r\n\r\n(defn run-length-encode\r\n  \"encodes a string with run-length-encoding\"\r\n  [s]\r\n  (apply str\r\n         (for\r\n          [x (partition-by identity s)]\r\n           (str\r\n            (when-not (= 1 (count x)) (count x)) (first x)))))\r\n\r\n(defn run-length-decode\r\n  \"decodes a run-length-encoded string\"\r\n  [s]\r\n  (->> s\r\n       (re-seq #\"[0-9]+.|[a-zA-Z\\s]\")\r\n       (map #(if (= (count %) 1) (str \"1\" %) %))\r\n       (map #(list (Integer. (reduce str \"\" (butlast %))) (str (last %))))\r\n       (map #(apply str (repeat (first %) (second %))))\r\n       (reduce str)))",
  "anagram" : "(ns anagram\r\n  (:require [clojure.string :refer [lower-case]]))\r\n\r\n(defn- anagram? [w c]\r\n  (let [w (lower-case w)\r\n        c (lower-case c)]\r\n    (and (= (sort w) (sort c))\r\n         (not= w c))))\r\n\r\n(defn anagrams-for [w coll]\r\n  (filter (partial anagram? w) coll))\r\n",
  "perfect_numbers" : "(ns perfect-numbers)\r\n\r\n(defn- get-divisors\r\n  \"Utility function to get the divisors of a number\"\r\n  [number]\r\n  (for [n (range 1 (inc (quot number 2))) :when (zero? (mod number n))]\r\n    n))\r\n\r\n(defn classify [number]\r\n  \"Classifies a positive integer as deficient, abundant or perfect\"\r\n  (if-not (pos? number)\r\n    (throw (IllegalArgumentException. \"Only positive numbers can be classified.\"))\r\n    (let [divisor-sum (apply + (get-divisors number))]\r\n      (cond\r\n        (> divisor-sum number) :abundant\r\n        (< divisor-sum number) :deficient\r\n        (= divisor-sum number) :perfect))))\r\n",
  "meetup" : "(ns meetup)\r\n\r\n(def day-structure\r\n  {1 :sunday 2 :monday 3 :tuesday 4 :wednesday\r\n   5 :thursday 6 :friday 7 :saturday})\r\n\r\n(defn leap-year? [year]\r\n  (cond (zero? (mod year 400)) true\r\n        (zero? (mod year 100)) false\r\n        :else  (zero? (mod year 4))))\r\n\r\n(defn zellers-congruence [input_year input_month input_day]\r\n  (let [month (+ (mod (+ input_month 9) 12) 3)\r\n        year (- input_year (quot (- month input_month) 12))\r\n        century (quot year 100)\r\n        century-year (mod year 100)]\r\n    (mod (+ input_day\r\n            (quot (* 26 (inc month)) 10)\r\n            century-year\r\n            (quot century-year 4)\r\n            (quot century 4)\r\n            (* 5 century)) 7)))\r\n\r\n(defn get-day-counts [year]\r\n  {1 31, 2 (if (leap-year? year) 29 28), 3 31, 4 30\r\n   5 31, 6 30, 7 31, 8 31, 9 30, 10 31, 11 30, 12 31})\r\n\r\n(defn get-days\r\n  ([year month]\r\n   (get-days year month\r\n             (zellers-congruence year month 1)\r\n             (get-in (get-day-counts year) [month])))\r\n  ([year month start-day limit]\r\n   (loop [count 2\r\n          day (inc start-day)\r\n          day-arrangement {1 (get-in day-structure [start-day])}]\r\n     (if (not= count (inc limit))\r\n       (recur  (inc count)\r\n               (if (= (inc day) 8) 1 (inc day))\r\n               (assoc day-arrangement count\r\n                      (get-in day-structure [day])))\r\n       day-arrangement))))\r\n\r\n(defn filter-by-day [year month day]\r\n  (let [days (get-days year month)]\r\n    (apply hash-map (flatten (filter #(-> % val (= day)) days)))))\r\n\r\n(defn filter-keys [year month day style]\r\n  (let [days (filter-by-day year month day)\r\n        dates (sort (keys days))]\r\n    (cond\r\n      (= style :first)\r\n      (nth dates 0)\r\n      (= style :second)\r\n      (nth dates 1)\r\n      (= style :third)\r\n      (nth dates 2)\r\n      (= style :fourth)\r\n      (nth dates 3)\r\n      (= style :last)\r\n      (nth dates (dec (count dates)))\r\n      (= style :teenth)\r\n      (first (filter #(and (> % 12) (< % 20)) (vec dates))))))\r\n\r\n(defn meetup [month year day style]\r\n  [year month (filter-keys year month day style)])",
  "hello_world" : "(ns hello-world)\r\n\r\n(defn hello []\r\n  \"Hello, World!\")\r\n",
  "wordy" : "(ns wordy\r\n  (:require [clojure.string :refer [join]]))\r\n\r\n(def  ops {\"plus\" +\r\n                    \"minus\" -\r\n                    \"multiplied by\" *\r\n                    \"divided by\" /})\r\n\r\n(def  tokens-pattern (re-pattern\r\n                               (str (join \"|\" (keys ops)) \"|-?\\\\d+|\\\\S+\")))\r\n\r\n(defn- parse-op [op-str]\r\n  (or (ops op-str)\r\n      (throw (IllegalArgumentException. (str \"unknown operator \" op-str)))))\r\n\r\n(defn evaluate [expr]\r\n  (if-let [[_ exprs] (re-matches #\"What is (.+)\\?\" expr)]\r\n    (if-let [[token & tokens] (re-seq tokens-pattern exprs)]\r\n      (reduce (fn [acc [op x]]\r\n                ((parse-op op) acc (Integer/parseInt x)))\r\n              (Integer/parseInt token) (partition-all 2 tokens))\r\n      (throw (IllegalArgumentException. \"no arithmetic expression found\")))\r\n    (throw (IllegalArgumentException. \"cannot recognize question\"))))\r\n",
  "go_counting" : "(ns go-counting)\r\n\r\n(defn grid->graph [xs]\r\n  (->> (for [x (-> xs count range), y (-> xs first count range)]\r\n         (case (get-in xs [x y])\r\n           \\W     [[y x] :white]\r\n           \\B     [[y x] :black]\r\n           \\space [[y x] :free]))\r\n       (into {})))\r\n\r\n(defn neighbors [pred stones [x y]]\r\n  (->> [[0 1] [0 -1] [1 0] [-1 0]]\r\n       (map (fn [[j k]] [(+ x j) (+ y k)]))\r\n       (filter (comp pred stones))))\r\n\r\n(defn territory-of [stones [x y]]\r\n  (if (= :free (stones [x y]))\r\n    (letfn [(f [[seen frontier]]\r\n              (let [nseen (reduce conj seen frontier)]\r\n                [nseen (->> frontier\r\n                            (mapcat #(neighbors #{:free} stones %))\r\n                            (filter (complement nseen)))]))]\r\n      (->> [#{} [[x y]]]\r\n           (iterate f)\r\n           (drop-while (comp seq second))\r\n           (ffirst)))\r\n    #{}))\r\n\r\n(defn territory-owner [stones territory]\r\n  (->> territory\r\n       (mapcat (partial neighbors  #{:black :white} stones))\r\n       (map stones)\r\n       (#(cond (empty? %)                    nil\r\n               (every? (partial = :black) %) :black\r\n               (every? (partial = :white) %) :white\r\n               :else                         nil))))\r\n\r\n(defn territory [grid [x y]]\r\n  (let [stones    (grid->graph grid)\r\n        territory (territory-of stones [x y])]\r\n    (if (nil? (stones [x y]))\r\n      (throw (Throwable. \"Invalid coordinate!\"))\r\n      {:stones territory :owner (territory-owner stones territory)})))\r\n\r\n(defn territories [grid]\r\n  (let [territories   (->> grid grid->graph keys (map (partial territory grid)))\r\n        territory-for #(->> territories (filter (comp % :owner)) (map :stones) (reduce concat) set)]\r\n    {:black-territory (territory-for (partial = :black))\r\n     :white-territory (territory-for (partial = :white))\r\n     :null-territory  (territory-for nil?)}))\r\n",
  "sieve" : "(ns sieve)\r\n\r\n(defn sieve\r\n  \"Returns a list of primes less than or equal to limit\"\r\n  [limit]\r\n  (loop [current-sieve (concat [false false] (range 2 (inc limit)))\r\n         last-prime 1]\r\n    (let [current-prime (->> current-sieve\r\n                             (drop (inc last-prime))\r\n                             (some identity))]\r\n      (if current-prime\r\n        (recur (map #(and %1 %2)\r\n                    (concat (repeat (inc current-prime) true)\r\n                            (cycle (concat (repeat (dec current-prime) true)\r\n                                           [false])))\r\n                    current-sieve)\r\n               current-prime)\r\n        (filter identity current-sieve)))))\r\n",
  "nth_prime" : "(ns nth-prime)\r\n\r\n(defn sqrt\r\n  \"Wrapper around java's sqrt method.\"\r\n  [number]\r\n  (int (Math/ceil (Math/sqrt number))))\r\n\r\n(defn divides?\r\n  \"Helper function to decide if a number is evenly divided by divisor.\"\r\n  [number divisor]\r\n  (zero? (mod number divisor)))\r\n\r\n(defn- prime-by-trial-division?\r\n  \"Simple trial division prime check.\"\r\n  [number]\r\n  (empty? (for [n (range 3 (inc (sqrt number)) 2) :when (divides? number n)] n)))\r\n\r\n(defn prime? [number]\r\n  (or (= 2 number)\r\n      (and (odd? number) (prime-by-trial-division? number))))\r\n\r\n(defn next-prime [start]\r\n  (loop [n (inc start)]\r\n    (if (prime? n)\r\n      n\r\n      (recur (inc n)))))\r\n\r\n(def primes (iterate next-prime 1))\r\n\r\n(defn nth-prime [index]\r\n  (when-not (pos? index)\r\n    (throw (IllegalArgumentException. \"nth-prime expects a positive integer for an argument\")))\r\n  (nth primes index))\r\n",
  "phone_number" : "(ns phone-number\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn- digits-only\r\n  [input]\r\n  (str/replace input #\"\\D\" \"\"))\r\n\r\n(defn- extract-parts\r\n  [input]\r\n  (if-let [matches (re-find #\"^1?([2-9]..)([2-9]..)(....)$\" input)]\r\n    (rest matches)\r\n    [\"000\" \"000\" \"0000\"]))\r\n\r\n(defn- parts\r\n  [input]\r\n  (-> input\r\n      digits-only\r\n      extract-parts))\r\n\r\n(defn number [input]\r\n  (str/join (parts input)))\r\n\r\n(defn area-code [input]\r\n  (first (parts input)))\r\n\r\n(defn pretty-print [input]\r\n  (let [[area-code exchange subscriber] (parts input)]\r\n    (str \"(\" area-code \") \" exchange \"-\" subscriber)))\r\n\r\n",
  "binary_search_tree" : "(ns binary-search-tree)\r\n\r\n(defn value [node] (first node))\r\n(defn left [node] (second node))\r\n(defn right [node] (last node))\r\n(defn singleton [n] [n nil nil])\r\n\r\n(defn insert [v node]\r\n  (if\r\n   (empty? node)\r\n    (singleton v)\r\n    (let [x (value node)]\r\n      (if\r\n       (>= x v)\r\n        [x (insert v (left node)) (right node)]\r\n        [x (left node) (insert v (right node))]))))\r\n\r\n(defn from-list [xs]\r\n  (reduce #(insert %2 %1) nil xs))\r\n\r\n(defn to-list [node]\r\n  (if\r\n   (empty? node)\r\n    node\r\n    (concat (to-list (left node)) [(value node)] (to-list (right node)))))\r\n",
  "binary" : "(ns binary)\r\n\r\n    \r\n\r\n(defn- power [[exponent bit]]\r\n  (if (= \"1\" bit)\r\n    (pow 2 exponent)\r\n    0))\r\n\r\n(defn- bits [string]\r\n  (->> string\r\n       (re-seq #\"[10]\")\r\n       reverse\r\n       (map-indexed vector)))\r\n\r\n(defn to-decimal [string]\r\n  (->> string\r\n       bits\r\n       (map power)\r\n       (apply +)))\r\n",
  "scrabble_score" : "(ns scrabble-score\r\n  (:require [clojure.string :refer [split]]))\r\n\r\n;; The letter values as shown in the README\r\n(def  letter-values\r\n  {\"AEIOULNRST\" 1\r\n   \"DG\"         2\r\n   \"BCMP\"       3\r\n   \"FHVWY\"      4\r\n   \"K\"          5\r\n   \"JX\"         8\r\n   \"QZ\"        10})\r\n\r\n;; A map from letter (as string) to score\r\n(def  letter->score\r\n  (reduce-kv (fn [acc letters score]\r\n               (-> (map str letters)\r\n                   (zipmap (repeat score))\r\n                   (->> (merge acc))))\r\n             {} letter-values))\r\n\r\n;; Defaults to 0 for non-alphabetic input\r\n(defn score-letter [letter]\r\n  (get letter->score (.toUpperCase (str letter)) 0))\r\n\r\n(defn score-word [word]\r\n  (reduce (fn [score letter]\r\n            (+ score (score-letter letter)))\r\n          0 word))\r\n",
  "queen_attack" : "(ns queen-attack\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn abs [n]\r\n  (if (neg? n) (- n) n))\r\n\r\n(def empty-board\r\n  (->> [\"_\" \"_\" \"_\" \"_\" \"_\" \"_\" \"_\" \"_\"]\r\n       (repeat 8)\r\n       vec))\r\n\r\n(defn board->str [board]\r\n  (->> board\r\n       (map #(str/join \" \" %))\r\n       (map #(str % \"\\n\"))\r\n       (apply str)))\r\n\r\n(defn board-string [{:keys [w b]}]\r\n  (-> empty-board\r\n      (cond-> w (assoc-in w \\W)\r\n              b (assoc-in b \\B))\r\n      board->str))\r\n\r\n(defn can-attack [{[wx wy] :w [bx by] :b :as state}]\r\n  (or (= wx bx)\r\n      (= wy by)\r\n      (= (abs (- wx bx))\r\n         (abs (- wy by)))))",
  "atbash_cipher" : "(ns atbash-cipher\r\n  (:require [clojure.string :as str]))\r\n\r\n(def  letters\r\n  (map char\r\n       (range (int \\a) (inc (int \\z)))))\r\n\r\n(def  to-cipher\r\n  (apply hash-map\r\n         (interleave letters (reverse letters))))\r\n\r\n(defn- sanitize\r\n  [plaintext]\r\n  (str/replace (str/lower-case plaintext) #\"\\W\" \"\"))\r\n\r\n(defn- cipher\r\n  [plain-char]\r\n  (or (to-cipher plain-char) plain-char))\r\n\r\n(defn- to-chunks\r\n  [character-list]\r\n  (map #(apply str %) (partition 5 5 \"\" character-list)))\r\n\r\n(defn encode\r\n  [plaintext]\r\n  (->> plaintext\r\n       sanitize\r\n       (map cipher)\r\n       to-chunks\r\n       (str/join \" \")))\r\n",
  "bob" : "(ns bob\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn remove-whitespace [s]\r\n  (js-eval (str \"\\\"\" s \"\\\"\" \".replace(/\\\\s+/g, '')\")))\r\n\r\n(defn- silence?    [msg] (= \"\" (remove-whitespace msg)))\r\n\r\n(defn- question?   [msg] (= \"?\" (last msg)))\r\n\r\n(defn- has-letter? [msg] (some #(Character/isLetter %) msg))\r\n\r\n(defn- shouting?   [msg] (and (= msg (str/upper-case msg))\r\n                              (has-letter? msg)))\r\n\r\n(defn- forceful-question? [msg]\r\n  (and (shouting? msg) (question? msg)))\r\n\r\n(defn response-for [input]\r\n  (let [clean (str/trim input)]\r\n    (cond\r\n      (forceful-question? clean) \"Calm down, I know what I'm doing!\"\r\n      (silence?  clean) \"Fine. Be that way!\"\r\n      (shouting? clean) \"Whoa, chill out!\"\r\n      (question? clean) \"Sure.\"\r\n      :else             \"Whatever.\")))\r\n\r\n",
  "rna_transcription" : "(defn dna->rna [x]\r\n (cond \r\n (= x \"G\") \"C\"\r\n (= x \"C\") \"G\" \r\n (= x \"A\") \"U\"\r\n (= x \"T\") \"A\")) \r\n\r\n(dna->rna \"C\") \r\n\r\n (defn- translate [c]\r\n (dna->rna c)) \r\n\r\n(defn to-rna [dna]\r\n (apply str (map translate dna)))\r\n",
  "acronym" : "(ns acronym\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn acronym [text]\r\n  (->> (re-seq #\"[A-Z]+[a-z]*|[a-z]+\" text)\r\n       (map ffirst)\r\n       (apply str)\r\n       str/upper-case))\r\n",
  "beer_song" : "(ns beer-song\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn many [n] (format \"%d bottles of beer on the wall, %d bottles of beer.\\nTake one down and pass it around, %d bottles of beer on the wall.\\n\" n n (dec n)))\r\n\r\n(def two \"2 bottles of beer on the wall, 2 bottles of beer.\\nTake one down and pass it around, 1 bottle of beer on the wall.\\n\")\r\n(def one \"1 bottle of beer on the wall, 1 bottle of beer.\\nTake it down and pass it around, no more bottles of beer on the wall.\\n\")\r\n(def zero \"No more bottles of beer on the wall, no more bottles of beer.\\nGo to the store and buy some more, 99 bottles of beer on the wall.\\n\")\r\n\r\n(defn verse [v]\r\n  (case (int v)\r\n    0 zero\r\n    1 one\r\n    2 two\r\n    (many v)))\r\n\r\n(defn sing\r\n  ([n]   (sing n 0))\r\n  ([n m] (->> (range n (dec m) -1)\r\n              (map verse)\r\n              (str/join \"\\n\"))))\r\n",
  "hamming" : "(ns hamming)\r\n\r\n(defn distance [a b]\r\n  (when (= (count a) (count b))\r\n    (count (filter true? (map not= a b)))))\r\n",
  "binary_search" : "(ns binary-search)\r\n\r\n(defn middle [alist]\r\n  (-> alist (count) (quot 2)))\r\n\r\n(defn search-for\r\n  [elem alist]\r\n  (let [middle (middle alist)\r\n        cur-elem (nth alist middle)]\r\n    (cond\r\n      (= cur-elem elem) middle\r\n      (or (= middle (count alist)) (zero? middle)) (throw (Exception. (format \"%s not found in list\" elem)))\r\n      (< cur-elem elem) (+ middle (search-for elem (drop middle alist)))\r\n      (> cur-elem elem) (search-for elem (take middle alist)))))\r\n",
  "bank_account" : "(ns bank-account)\r\n\r\n(defn open-account []\r\n  (atom 0))\r\n\r\n(defn close-account [acct]\r\n  (reset! acct nil))\r\n\r\n(defn get-balance [acct]\r\n  @acct)\r\n\r\n(defn update-balance [account amount]\r\n  (swap! account + amount))",
  "octal" : "(ns octal)\r\n\r\n(defn to-decimal [num]\r\n  (loop [sum 0, num num]\r\n    (if (empty? num)\r\n      sum\r\n      (let [diff (.compareTo (first num) \\0)]\r\n        (if (<= 0 diff 7)\r\n          (recur (+ (* sum 8) diff) (next num))\r\n          0)))))",
  "raindrops" : "(ns raindrops)\r\n\r\n(def  sound-map\r\n  {\"3\" \"Pling\"\r\n   \"5\" \"Plang\"\r\n   \"7\" \"Plong\"})\r\n\r\n(defn parseInt [s]\r\n (js-eval (str \"parseInt(\" s \")\")))\r\n\r\n(defn- divisors\r\n  [number]\r\n  (filter\r\n   (fn [sound]\r\n     (zero? (rem number (parseInt (first sound)))))\r\n   (seq sound-map)))\r\n\r\n(defn- sounds-for\r\n  [number]\r\n  (let [divisors (divisors number)\r\n        sounds (map last divisors)]\r\n    (apply str sounds)))\r\n\r\n(defn convert\r\n  [number]\r\n  (let [sounds (sounds-for number)]\r\n    (if (blank? sounds)\r\n      (str number)\r\n      sounds)))\r\n",
  "reverse_string" : "(ns reverse-string\r\n  (:require [clojure.string :as s]))\r\n\r\n(defn reverse-string [s]\r\n  (apply str (reverse s)))\r\n",
  "sublist" : "(ns sublist)\r\n\r\n(defn- list-contains?\r\n  \"Returns truthy when list2 is contained within list1, nil otherwise\"\r\n  [list1 list2]\r\n  (some #(when (= % list2) val)\r\n        (partition (count list2) 1 list1)))\r\n\r\n(defn classify\r\n  \"Classifies two lists based on whether coll1 is the same list, a superlist,\r\n  a sublist, or disjoint (unequal) from coll2.\"\r\n  [coll1 coll2]\r\n  (let [len1 (count coll1)\r\n        len2 (count coll2)]\r\n    (cond\r\n      (= coll1 coll2) :equal\r\n      (and (> len1 len2) (list-contains? coll1 coll2)) :superlist\r\n      (and (> len2 len1) (list-contains? coll2 coll1)) :sublist\r\n      :else :unequal)))\r\n",
  "triangle" : "(ns triangle)\r\n\r\n(defn is-valid? [s1 s2 s3]\r\n  (and\r\n   (> s1 0) (> s2 0) (> s3 0)\r\n   (>= (+ s1 s2) s3)\r\n   (>= (+ s1 s3) s2)\r\n   (>= (+ s2 s3) s1)))\r\n\r\n(defn equilateral? [s1 s2 s3]\r\n  (and (is-valid? s1 s2 s3) (= s1 s2 s3)))\r\n\r\n(defn isosceles? [s1 s2 s3]\r\n  (and (is-valid? s1 s2 s3) (or (= s1 s2) (= s1 s3) (= s2 s3))))\r\n\r\n(defn scalene? [s1 s2 s3]\r\n  (and (not (isosceles? s1 s2 s3)) (is-valid? s1 s2 s3)))",
  "pig_latin" : "(ns pig-latin\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn- starts-with-any [prefixes word]\r\n  (some (partial str/starts-with? word) prefixes))\r\n\r\n(defn- starts-with-vowel-like? [word]\r\n  (starts-with-any #{\"yt\" \"xr\"} word))\r\n\r\n(defn- starts-with-vowel? [word]\r\n  (starts-with-any #{\"a\" \"e\" \"i\" \"o\" \"u\"} word))\r\n\r\n(defn- starts-with-two-letter-prefix? [word]\r\n  (starts-with-any #{\"ch\" \"qu\" \"th\" \"rh\"} word))\r\n\r\n(defn- starts-with-three-letter-prefix? [word]\r\n  (starts-with-any #{\"thr\" \"sch\"} word))\r\n\r\n(defn- starts-with-qu-and-preceding-consonant? [word]\r\n  (and (not (starts-with-vowel? word))\r\n       (str/starts-with? (subs word 1) \"qu\")))\r\n\r\n(defn- rotate [word n]\r\n  (str (subs word n) (subs word 0 n)))\r\n\r\n(defn- append-ay [word]\r\n  (str word \"ay\"))\r\n\r\n(defn- translate-word [word]\r\n  (cond\r\n    (or (starts-with-vowel? word)\r\n        (starts-with-vowel-like? word))\r\n    (append-ay word)\r\n\r\n    (or\r\n     (starts-with-three-letter-prefix? word)\r\n     (starts-with-qu-and-preceding-consonant? word))\r\n    (append-ay (rotate word 3))\r\n\r\n    (starts-with-two-letter-prefix? word)\r\n    (append-ay (rotate word 2))\r\n\r\n    :else\r\n    (append-ay (rotate word 1))))\r\n\r\n(defn translate [words]\r\n  (->> (str/split words #\" \")\r\n       (map translate-word)\r\n       (str/join \" \")))\r\n",
  "clock" : "(ns clock)\r\n\r\n(defn clock\r\n  \"Return a 24 hour clock representation of the given hours and minutes.\"\r\n  [in-hour in-minute]\r\n  (let [total-minutes (mod (+ (* in-hour 60) in-minute) (* 60 24))\r\n        hours (mod (quot total-minutes 60) 24)\r\n        minutes (mod total-minutes 60)]\r\n    {:hour hours :minute minutes}))\r\n\r\n(defn clock->string\r\n  \"Print the HH:MM representation of a clock.\"\r\n  [in-clock]\r\n  (format \"%02d:%02d\" (:hour in-clock) (:minute in-clock)))\r\n\r\n(defn add-time\r\n  \"Add minutes to the given clock.\"\r\n  [in-clock minutes-to-add]\r\n  (clock (:hour in-clock) (+ (:minute in-clock) minutes-to-add)))\r\n",
  "allergies" : "(ns allergies)\r\n\r\n(def  allergens\r\n  [:eggs :peanuts :shellfish :strawberries :tomatoes :chocolate :pollen :cats])\r\n\r\n(defn- flagged?\r\n  [flags index]\r\n  (-> (bit-shift-right flags index)\r\n      (bit-and 1)\r\n      (pos?)))\r\n\r\n(defn allergies\r\n  \"Given an 8-bit bitmap of flags, return the list of matching allergens.\"\r\n  [flags]\r\n  (keep-indexed (fn [index allergen]\r\n                  (when (flagged? flags index)\r\n                    allergen))\r\n                allergens))\r\n\r\n(defn allergic-to?\r\n  \"Given an 8-bit bitmap of flags and an allergen, return a boolean\r\n  indicating whether or not the patient is allergic to the given allergen.\"\r\n  [flags allergen]\r\n  (some #{allergen} (allergies flags)))\r\n",
  "say" : "(ns say\r\n  (:require [clojure.pprint :as pp]\r\n            [clojure.string :as s]))\r\n\r\n(defn number [input]\r\n  (if\r\n   (or (< input 0) (> input 999999999999))\r\n    (throw (IllegalArgumentException. \"Out of range\"))\r\n    (s/replace (pp/cl-format nil \"~R\" input) #\",\" \"\")))\r\n",
  "luhn" : "(ns luhn\r\n  (:require [clojure.string :as string]))\r\n\r\n(defn to-reversed-digits\r\n  \"returns a lazy sequence of least to most significant digits of n\"\r\n  [n]\r\n  (->> [n 0]\r\n       (iterate (fn [[i _]] [(quot i 10) (mod i 10)]))\r\n       (take-while (complement #{[0 0]}))\r\n       (map second)\r\n       rest))\r\n\r\n(defn checksum\r\n  \"returns the luhn checksum of n, assuming it has a check digit\"\r\n  [n]\r\n  (-> (->> n\r\n           to-reversed-digits\r\n           (map * (cycle [1 2]))\r\n           (map #(if (>= % 10) (- % 9) %))\r\n           (apply +))\r\n      (mod 10)))\r\n\r\n(defn string->long\r\n  \"Strips any non-digit characters and converts the string into a Long\"\r\n  [n]\r\n  (-> n (string/replace #\"[^0-9]+\" \"\") Long/parseLong))\r\n\r\n(defn valid?\r\n  \"whether n has a valid luhn check-digit\"\r\n  [n]\r\n  ; Numbers with non digit/whitespace or only 1 digit are invalid\r\n  (if (or (re-find #\"[^0-9\\s]+\" n) (>= 1 (count (string/trim n))))\r\n    false\r\n    (zero? (-> n string->long checksum))))\r\n",
  "poker" : "(ns poker)\r\n\r\n(def base-values\r\n  {\"2\" 2\r\n   \"3\" 3\r\n   \"4\" 4\r\n   \"5\" 5\r\n   \"6\" 6\r\n   \"7\" 7\r\n   \"8\" 8\r\n   \"9\" 9\r\n   \"10\" 10\r\n   \"J\" 11\r\n   \"Q\" 12\r\n   \"K\" 13})\r\n\r\n(def values-low-as\r\n  (into base-values\r\n        {\"A\" 1}))\r\n\r\n(def values-high-as\r\n  (into base-values\r\n        {\"A\" 14}))\r\n\r\n(defn value-freq [hand]\r\n  (->> hand\r\n       (group-by :value)\r\n       (vals)\r\n       (map count)\r\n       (sort)))\r\n\r\n(defn one-pair? [hand]\r\n  (= [1 1 1 2] (value-freq hand)))\r\n\r\n(defn two-pair? [hand]\r\n  (= [1 2 2] (value-freq hand)))\r\n\r\n(defn three-of-a-kind? [hand]\r\n  (= [1 1 3] (value-freq hand)))\r\n\r\n(defn straight? [hand]\r\n  (->> hand\r\n       (map :value)\r\n       (sort)\r\n       (partition 2 1)\r\n       (map (partial apply -))\r\n       (every? (partial = -1))))\r\n\r\n(defn flush? [hand]\r\n  (->> hand\r\n       (map :color)\r\n       (apply =)))\r\n\r\n(defn full-house? [hand]\r\n  (= [2 3] (value-freq hand)))\r\n\r\n(defn four-of-a-kind? [hand]\r\n  (= [1 4] (value-freq hand)))\r\n\r\n(defn straight-flush? [hand]\r\n  (and (flush? hand) (straight? hand)))\r\n\r\n(defn category [hand]\r\n  (condp #(%1 %2) hand\r\n    straight-flush? 8\r\n    four-of-a-kind? 7\r\n    full-house? 6\r\n    flush? 5\r\n    straight? 4\r\n    three-of-a-kind? 3\r\n    two-pair? 2\r\n    one-pair? 1\r\n    0))\r\n\r\n(defn highcards [hand]\r\n  (->> hand\r\n       (map :value)\r\n       (frequencies)\r\n       (map reverse)\r\n       (map vec)\r\n       (sort)\r\n       (reverse)\r\n       (vec)))\r\n\r\n(defn read-hand [raw-hand values]\r\n  (vec (for [[_ rank color] (re-seq #\"(\\d+|[JQKA])([CDHS])\" raw-hand)]\r\n         {:value (values rank)\r\n          :color color})))\r\n\r\n(defn score\r\n  ([raw-hand]\r\n   (last (sorted-set (score raw-hand values-high-as)\r\n                     (score raw-hand values-low-as))))\r\n  ([raw-hand values]\r\n   (-> raw-hand\r\n       (read-hand values)\r\n       ((juxt category highcards)))))\r\n\r\n(defn max-by-score [raw-hands]\r\n  (->> raw-hands\r\n       (group-by score)\r\n       (into (sorted-map))\r\n       (vals)\r\n       (last)))\r\n\r\n(defn best-hands [hands]\r\n  (max-by-score hands))",
  "all_your_base" : "(ns all-your-base)\r\n\r\n(defn- digits->decimal\r\n  \"Converts a sequence of digits given in input-base into decimal format.\"\r\n  [input-base digits]\r\n  (loop [sum 0\r\n         [num & nums] digits]\r\n    (if num\r\n      (recur (+ (* sum input-base) num) nums)\r\n      sum)))\r\n\r\n(defn- decimal->digits\r\n  \"Converts a decimal number into a sequence of digits in the desired output base.\"\r\n  [output-base number]\r\n  (loop [digits nil\r\n         num number]\r\n    (if (zero? num)\r\n      digits\r\n      (recur (conj digits (mod num output-base)) (quot num output-base)))))\r\n\r\n(defn convert\r\n  \"Converts a sequence of digits given in input-base into a sequence of digits in the desired output-base.\"\r\n  [input-base digits output-base]\r\n  (cond\r\n    (some #(< % 2) (list input-base output-base)) nil\r\n    (not-every? #(and (not (neg? %)) (< % input-base)) digits) nil\r\n    (empty? digits) ()\r\n    (every? #(zero? %) digits) '(0)\r\n    :else (->> digits\r\n               (digits->decimal input-base)\r\n               (decimal->digits output-base))))\r\n",
  "accumulate" : "(ns accumulate)\r\n\r\n(defn accumulate [f xs]\r\n  (loop [xs xs\r\n         accum []]\r\n    (if\r\n     (empty? xs) accum\r\n     (recur (rest xs) (conj accum (f (first xs)))))))\r\n\r\n",
  "hexadecimal" : "(ns hexadecimal)\r\n\r\n(defn- char-between [start end c]\r\n  (let [ascii (int c)]\r\n    (and (>= ascii (int start)) (<= ascii (int end)))))\r\n\r\n(def is-digit (partial char-between \\0 \\9))\r\n(def is-a-to-f (partial char-between \\a \\f))\r\n\r\n(defn- is-hex-digit [c]\r\n  (or (is-digit c) (is-a-to-f c)))\r\n\r\n(defn- digit-to-int [c]\r\n  (cond\r\n    (is-digit c) (- (int c) (int \\0))\r\n    (is-a-to-f c) (+ (- (int c) (int \\a)) 10)\r\n    :else (throw (Exception. \"Character is not a hex digit\"))))\r\n\r\n(defn hex-to-int [digits]\r\n  (if\r\n   (some (complement is-hex-digit) digits) 0\r\n   (reduce #(+ (digit-to-int %2) (* %1 16)) 0 digits)))\r\n\r\n",
  "series" : "(ns series)\r\n\r\n(defn slices [string n]\r\n  (if (zero? n)\r\n    [\"\"]\r\n    (loop [string string, acc []]\r\n      (if (< (count string) n)\r\n        acc\r\n        (recur (rest string) (conj acc (apply str (take n string))))))))\r\n",
  "kindergarten_garden" : "(ns kindergarten-garden)\r\n\r\n(def default-students [\"Alice\" \"Bob\" \"Charlie\" \"David\" \"Eve\" \"Fred\" \"Ginny\"\r\n                       \"Harriet\" \"Ileana\" \"Joseph\" \"Kincaid\" \"Larry\"])\r\n\r\n(def seeds {\\G :grass \\C :clover \\R :radishes \\V :violets})\r\n\r\n(defn row-to-seeds [row-string]\r\n  (map seeds row-string))\r\n\r\n(defn garden-to-rows [garden]\r\n  (clojure.string/split-lines garden))\r\n\r\n(defn garden\r\n  ([string]\r\n   (garden string default-students))\r\n  ([string students]\r\n   (let [students     (map #(keyword (clojure.string/lower-case %1)) (sort students))\r\n         [front back] (map #(partition 2 %1)\r\n                           (map row-to-seeds (garden-to-rows string)))]\r\n     (->> (interleave front back)\r\n          (partition 2)\r\n          (map flatten)\r\n          (map vec)\r\n          (zipmap students)))))\r\n",
  "word_count" : "(defn words [s]\r\n  (re-seq #\"\\\\w+\" s))\r\n\r\n(defn word-count [s]\r\n  (-> s lower-case words frequencies))\r\n",
  "yacht" : "(ns yacht)\r\n\r\n(defn yacht [dices]\r\n  (if (= (count (set dices)) 1) 50 0))\r\n\r\n(defn dice-frequencies [dices]\r\n  (mapv #(if (nil? %) 0 %)\r\n        (map (fn [v] (get (frequencies dices) v))\r\n             (range 1 7))))\r\n\r\n(defn appearances [dices diceValue]\r\n  (get (dice-frequencies dices) (dec diceValue)))\r\n\r\n(defn getSumOfDices [dices]\r\n  (reduce + 0 dices))\r\n\r\n(defn four-of-kind [dices]\r\n  (let [counterArray (dice-frequencies dices)\r\n        scores (remove nil? (for [i (range 6)]\r\n                              (when (>= (get counterArray i) 4)\r\n                                (* 4 (inc i)))))]\r\n    (if (empty? scores) 0 (first scores))))\r\n\r\n(defn little-straight [dices]\r\n  (if (= (sort dices) [1 2 3 4 5]) 30 0))\r\n\r\n(defn big-straight [dices]\r\n  (if (= (sort dices) [2 3 4 5 6]) 30 0))\r\n\r\n(defn full-house [dices]\r\n  (let [counterArray (dice-frequencies dices)]\r\n    (if (and (contains? (set counterArray) 2)\r\n             (contains? (set counterArray) 3))\r\n      (reduce + dices)\r\n      0)))\r\n\r\n(defn score [dices category]\r\n  (case category\r\n    \"yacht\" (yacht dices)\r\n    \"ones\" (appearances dices 1)\r\n    \"twos\" (* 2 (appearances dices 2))\r\n    \"threes\" (* 3 (appearances dices 3))\r\n    \"fours\" (* 4 (appearances dices 4))\r\n    \"fives\" (* 5 (appearances dices 5))\r\n    \"sixes\" (* 6 (appearances dices 6))\r\n    \"full house\" (full-house dices)\r\n    \"four of a kind\" (four-of-kind dices)\r\n    \"little straight\" (little-straight dices)\r\n    \"big straight\" (big-straight dices)\r\n    \"choice\" (getSumOfDices dices)\r\n    0))\r\n",
  "armstrong_numbers" : "(ns armstrong-numbers)\r\n\r\n(defn expt [base pow]\r\n  (reduce * 1 (repeat pow base)))\r\n\r\n(defn armstrong? [n]\r\n  (let [digits (map #(read-string (str %)) (str n))\r\n        l      (count digits)]\r\n  (= n (reduce + 0 (map #(expt % l) digits)))))\r\n",
  "grains" : "(ns grains)\r\n\r\n   \r\n\r\n(defn square [number]\r\n  (pow 2 (dec number)))\r\n\r\n(def  square-numbers (rest (range 65)))\r\n\r\n(defn total []\r\n  (apply + (map square square-numbers)))\r\n",
  "proverb" : "(ns proverb\r\n  (:require [clojure.string :as str]))\r\n\r\n(def last-line \"And all for the want of a %s.\")\r\n\r\n(defn- line [[cause-subject effect-subject]]\r\n  (format \"For want of a %s the %s was lost.\" cause-subject effect-subject))\r\n\r\n(defn recite [subjects]\r\n  (if (empty? subjects) \"\"\r\n    (->> subjects\r\n    (partition 2 1)\r\n    (map line)\r\n    (#(conj (vec %) (format last-line (first subjects))))\r\n    (str/join \"\\n\"))))\r\n",
  "collatz_conjecture" : "(ns collatz-conjecture)\r\n\r\n(defn collatz-helper [n]\r\n  (cond (= 1 n)   1\r\n        (even? n) (/ n 2)\r\n        :else     (inc (* 3 n))))\r\n\r\n(defn collatz [n]\r\n  (if (> n 0)\r\n    (count (take-while #(not= 1 %)\r\n                       (iterate collatz-helper n)))\r\n    (throw (IllegalArgumentException.\r\n            \"Just defined for numbers greater than 0.\"))))\r\n",
  "pangram" : "(ns pangram)\r\n\r\n(defn- char<= [ch1 ch2] (<= (compare ch1 ch2) 0))\r\n\r\n(defn pangram? [input]\r\n  (->> input\r\n       (into [] (comp (map #(Character/toLowerCase %))\r\n                      (filter #(and (char<= \\a %) (char<= % \\z)))\r\n                      (distinct)))\r\n       count\r\n       (= 26)))\r\n",
  "secret_handshake" : "(ns secret-handshake)\r\n\r\n(defn- int->reversed-binary [int]\r\n  (-> int\r\n      (Integer/toBinaryString)\r\n      (reverse)))\r\n\r\n(defn- convert [integer]\r\n  (remove nil?\r\n          (map (fn [command binary]\r\n                 (when (= \\1 binary) command))\r\n               [\"wink\" \"double blink\" \"close your eyes\" \"jump\"]\r\n               (int->reversed-binary integer))))\r\n\r\n(defn commands [integer]\r\n  (let [cmds (convert integer)]\r\n    (if (= \\1 (nth (int->reversed-binary integer) 4 \\0))\r\n      (reverse cmds)\r\n      cmds)))\r\n",
  "protein_translation" : "(ns protein-translation)\r\n\r\n(defn translate-codon [codon]\r\n  (case codon\r\n    \"AUG\" \"Methionine\"\r\n    (\"UUU\" \"UUC\") \"Phenylalanine\"\r\n    (\"UUA\" \"UUG\") \"Leucine\"\r\n    (\"UCU\" \"UCC\" \"UCA\" \"UCG\") \"Serine\"\r\n    (\"UAU\" \"UAC\") \"Tyrosine\"\r\n    (\"UGU\" \"UGC\") \"Cysteine\"\r\n    \"UGG\" \"Tryptophan\"\r\n    (\"UAA\" \"UAG\" \"UGA\") \"STOP\"))\r\n\r\n(defn translate-rna [rna]\r\n  (->> rna\r\n       (partition 3)\r\n       (map (partial apply str))\r\n       (map translate-codon)\r\n       (take-while #(not= \"STOP\" %))))\r\n",
  "rotational_cipher" : "(ns rotational-cipher)\r\n\r\n(defn  spinner [s a]\r\n  (let [a (int a)\r\n        spin (fn [c] (mod (+ c s) 26))]\r\n    (fn [c]\r\n      (let [c (- (int c) a)]\r\n        (char (+ (spin c) a))))))\r\n\r\n(defn  upper-spinner [s]\r\n  (spinner s \\A))\r\n\r\n(defn  lower-spinner [s]\r\n  (spinner s \\a))\r\n\r\n(defn  cipher [spin]\r\n  (let [upper-spin (upper-spinner spin)\r\n        lower-spin (lower-spinner spin)]\r\n    (fn [c]\r\n      (cond\r\n        (Character/isUpperCase c) (upper-spin c)\r\n        (Character/isLowerCase c) (lower-spin c)\r\n        :default c))))\r\n\r\n(defn rotate [text spin]\r\n  (let [cipher (cipher spin)]\r\n    (apply str (map cipher text))))\r\n",
  "two_fer" : "(ns two-fer)\r\n\r\n(defn two-fer\r\n  ([] (str \"One for you, one for me.\"))\r\n  ([name] (str \"One for \" name \", one for me.\")))\r\n",
  "sum_of_multiples" : "(ns sum-of-multiples)\r\n\r\n(defn- divides?\r\n  ([n]   (fn [d] (divides? n d)))\r\n  ([n d] (zero? (rem n d))))\r\n\r\n(defn sum-of-multiples [multiples n]\r\n  (reduce (fn [sum x] (cond-> sum (some (divides? x) multiples) (+ x)))\r\n          0 (range 1 n)))\r\n",
  "isbn_verifier" : "(ns isbn-verifier)\r\n\r\n(defn is-in? [xs x] (some #(= x %) xs))\r\n\r\n(defn isbn-chars [isbn]\r\n  (filter #(is-in? [\\0 \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9 \\X] %) isbn))\r\n\r\n(defn isbn? [isbn]\r\n  (let [chars (isbn-chars isbn)\r\n        nums  (map #(if (= \\X %) 10 (Character/digit % 10)) chars)]\r\n    (and (-> chars butlast (is-in? \\X) not)\r\n         (= 10 (count chars))\r\n         (as-> nums x\r\n           (map #(* %1 %2) (range 10 0 -1) x)\r\n           (reduce + x)\r\n           (mod x 11)\r\n           (zero? x)))))\r\n",
  "strain" : "(ns strain)\r\n\r\n(defn retain\r\n  \"a simple (nonlazy) reimplementation of filter\"\r\n  [pred s]\r\n  (let [[first & rest] s]\r\n    (cond\r\n      (empty? s) '()\r\n      (pred first) (cons first (retain pred rest))\r\n      :else (retain pred rest))))\r\n\r\n(defn discard\r\n  \"a simple (nonlazy) reimplementation of remove\"\r\n  [pred s]\r\n  (retain (complement pred) s))\r\n",
  "matching_brackets" : "(ns matching-brackets)\r\n\r\n(defn valid? [s]\r\n  (let [pairs {\\) \\( \\] \\[ \\} \\{}\r\n        opening (set (vals pairs))\r\n        closing (set (keys pairs))]\r\n    (loop [stack [] [x & xs :as s] s]\r\n      (cond (empty? s) (empty? stack)\r\n            (opening x) (recur (conj stack x) xs)\r\n            (closing x) (if (= (peek stack) (pairs x))\r\n                          (recur (pop stack) xs)\r\n                          false)\r\n            :else (recur stack xs)))))\r\n",
  "trinary" : "(ns trinary)\r\n\r\n(defn to-decimal [num]\r\n  (loop [sum 0, num num]\r\n    (if (empty? num)\r\n      sum\r\n      (let [diff (.compareTo (first num) \\0)]\r\n        (if (<= 0 diff 2)\r\n          (recur (+ (* sum 3) diff) (next num))\r\n          0)))))\r\n",
  "etl" : "(ns etl\r\n  (:require [clojure.string :refer [lower-case]]))\r\n\r\n(defn transform [extract]\r\n  (into {}\r\n        (for [[score letters] extract\r\n              letter          letters]\r\n          [(lower-case letter) score])))\r\n",
  "largest_series_product" : "(ns largest-series-product)\r\n\r\n(defn- char->digit [c]\r\n  {:pre [(Character/isDigit c)]}\r\n  (Character/digit c 10))\r\n\r\n(defn- digits [ds] (map char->digit ds))\r\n\r\n(defn- slices [n ds] (partition n 1 (digits ds)))\r\n\r\n(defn largest-product [size ds]\r\n  (cond\r\n    (zero? size)        1\r\n    (> size (count ds)) (throw (Exception. \"Span must not exceed length.\"))\r\n    :else               (apply max (map (partial apply *) (slices size ds)))))\r\n",
  "robot_simulator" : "(ns robot-simulator)\r\n\r\n(def directions [:north :east :south :west])\r\n\r\n(defn robot [coordinates bearing]\r\n  {:coordinates coordinates :bearing bearing})\r\n\r\n(defn turn [bearing direction-list]\r\n  (let [dir-stream (drop-while #(not (= bearing %1)) (cycle direction-list))]\r\n    (nth dir-stream 1)))\r\n\r\n(defn turn-right [bearing]\r\n  (turn bearing directions))\r\n\r\n(defn turn-left [bearing]\r\n  (turn bearing (reverse directions)))\r\n\r\n(defn advance [coordinates bearing]\r\n  (let [x (:x coordinates)\r\n        y (:y coordinates)]\r\n    (cond\r\n      (= :north bearing) {:x x :y (inc y)}\r\n      (= :south bearing) {:x x :y (dec y)}\r\n      (= :east  bearing) {:x (inc x) :y y}\r\n      (= :west  bearing) {:x (dec x) :y y})))\r\n\r\n(defn simulate [instructions current-state]\r\n  (loop [instructions  instructions\r\n         current-state current-state]\r\n    (let [instruction (first instructions)\r\n          remainder   (rest  instructions)\r\n          coordinates (:coordinates current-state)\r\n          bearing     (:bearing current-state)\r\n          next-state  (cond\r\n                        (= \\L instruction)\r\n                        (robot coordinates (turn-left bearing))\r\n                        (= \\R instruction)\r\n                        (robot coordinates (turn-right bearing))\r\n                        :else\r\n                        (robot (advance coordinates bearing) bearing))]\r\n      (if (seq remainder)\r\n        (recur remainder next-state)\r\n        next-state))))\r\n\r\n",
  "change" : "(ns change)\r\n\r\n(def algo\r\n  (memoize (fn [amount coins]\r\n             (let [smaller (filter #(<= % amount) coins)]\r\n               (if (empty? smaller) [amount]\r\n                 (apply min-key\r\n                        count\r\n                        ; check if valid solution, i.e. the final amount was zero\r\n                        (filter (comp zero? first)\r\n                                (map\r\n                                  (fn [coin]\r\n                                    (concat\r\n                                      (algo (rem amount coin) smaller)\r\n                                      (repeat (quot amount coin) coin)))\r\n                                  smaller))))))))\r\n\r\n(defn issue [amount coins] \r\n  (try\r\n    (let [[x & xs] (algo amount coins)]\r\n      (if (zero? x) xs\r\n        (throw (IllegalArgumentException. \"cannot change\"))))\r\n    ; thrown by apply min-key if we don't have the right coins to issue change\r\n    (catch clojure.lang.ArityException e (throw (IllegalArgumentException. \"cannot change\")))))\r\n",
  "grade_school" : "(ns grade-school)\r\n\r\n(defn grade\r\n  \"show the roster for a specific grade\"\r\n  [db grade-level]\r\n  (db grade-level []))\r\n\r\n(defn add\r\n  \"add student to roster for grade\"\r\n  [db student grade-level]\r\n  (let [roster (grade db grade-level)]\r\n    (assoc db grade-level (conj roster student))))\r\n\r\n(defn sorted\r\n  \"show the sorted roster for each grade\"\r\n  [db]\r\n  (into (sorted-map)\r\n        (for [[grade-level roster] db]\r\n          [grade-level (sort roster)])))\r\n"
}